/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.dann41.kafkastreams

import com.dann41.kafkastreams.events.*
import com.dann41.kafkastreams.serdes.JsonSerde
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.KotlinFeature
import com.fasterxml.jackson.module.kotlin.KotlinModule
import org.apache.kafka.common.serialization.Serdes
import org.apache.kafka.streams.KafkaStreams
import org.apache.kafka.streams.KeyValue
import org.apache.kafka.streams.StreamsBuilder
import org.apache.kafka.streams.errors.StreamsUncaughtExceptionHandler
import org.apache.kafka.streams.kstream.*
import java.util.concurrent.CountDownLatch
import kotlin.system.exitProcess


class App {

    companion object {
        private const val VEHICLES_TOPIC = "vehicle"
        private const val PRICES_TOPIC = "vehicle_price"
        private const val PHOTOS_TOPIC = "vehicle_photo"
        private const val FULL_VEHICLE_TOPIC = "full_vehicle"
    }

    fun execute() {
        val serdes = SerdesDefinition(objectMapper())

        val streamsBuilder = StreamsBuilder()

        val vehiclesTable = vehiclesTable(streamsBuilder, serdes)
        val vehiclesWithPriceTable = vehiclesWithPriceTable(streamsBuilder, serdes, vehiclesTable)
        val vehiclePhotosTable = vehiclePhotosTable(streamsBuilder, serdes)

        partialVehicleTable(vehiclesWithPriceTable, vehiclePhotosTable, serdes)
            .filter { _, value -> value.isFullVehicle() }
            .mapValues { _, value -> value.toFullVehicle() }
            .toStream()
            .peek { key, value -> println("Processing full vehicle $key. $value") }
            .to(FULL_VEHICLE_TOPIC, Produced.with(Serdes.String(), serdes.fullVehicle))

        val topology = streamsBuilder.build()
        println(topology.describe())

        val streams = KafkaStreams(topology, KafkaProperties.properties)

        streams.setUncaughtExceptionHandler { exception ->
            println(exception?.message)
            StreamsUncaughtExceptionHandler.StreamThreadExceptionResponse.REPLACE_THREAD
        }

        start(streams)
    }

    private fun objectMapper(): ObjectMapper {
        val objectMapper = ObjectMapper()
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        objectMapper.registerModule(JavaTimeModule())
        objectMapper.registerModule(
            KotlinModule.Builder()
                .configure(KotlinFeature.NullToEmptyCollection, true)
                .configure(KotlinFeature.NullToEmptyMap, true)
                .configure(KotlinFeature.NullIsSameAsDefault, true)
                .configure(KotlinFeature.StrictNullChecks, false)
                .build()
        )
        return objectMapper
    }

    private fun vehiclesTable(
        streamsBuilder: StreamsBuilder,
        serdes: SerdesDefinition
    ) = streamsBuilder
        .table(VEHICLES_TOPIC, Materialized.with(Serdes.String(), serdes.vehicle))

    private fun vehiclesWithPriceTable(
        streamsBuilder: StreamsBuilder,
        serdes: SerdesDefinition,
        vehiclesTable: KTable<String, Vehicle>?
    ) = streamsBuilder
        .table(PRICES_TOPIC, Materialized.with(Serdes.String(), serdes.price))
        .join(
            vehiclesTable,
            { price: VehiclePrice, vehicle: Vehicle ->
                PartialVehicle(vehicle.id, vehicle, price)
            },
            Named.`as`("vehicle_with_price_table"),
            Materialized.with(Serdes.String(), serdes.partialVehicle)
        )

    private fun vehiclePhotosTable(
        streamsBuilder: StreamsBuilder,
        serdes: SerdesDefinition
    ) = streamsBuilder
        .table(PHOTOS_TOPIC, Materialized.with(Serdes.String(), serdes.photo))
        .filter { _, value -> value != null }
        .groupBy({ _, value -> KeyValue.pair(value.vehicle, value) }, Grouped.with(Serdes.String(), serdes.photo))
        .aggregate(
            { VehiclePhotos(emptyList()) },
            { _, value, photos -> VehiclePhotos(photos.photos + value) },
            { _, value, photos -> VehiclePhotos(photos.photos - value) },
            Named.`as`("vehicle_photos_table"),
            Materialized.with(Serdes.String(), serdes.photos)
        )

    private fun partialVehicleTable(
        vehiclesWithPriceTable: KTable<String, PartialVehicle>,
        vehiclePhotosTable: KTable<String, VehiclePhotos>?,
        serdes: SerdesDefinition
    ) = vehiclesWithPriceTable.join(
        vehiclePhotosTable,
        { partialVehicle, photos -> partialVehicle.copy(photos = photos.photos) },
        Named.`as`("vehicle_with_price_and_photos_table"),
        Materialized.with(Serdes.String(), serdes.partialVehicle)
    )

    private fun start(streams: KafkaStreams) {
        val latch = CountDownLatch(1)

        Runtime.getRuntime().addShutdownHook(object : Thread("streams-shutdown-hook") {
            override fun run() {
                println("Closing")
                streams.close()
                latch.countDown()
            }
        })

        try {
            println("Start")
            streams.start()
            println("Started")
            latch.await()
        } catch (e: Throwable) {
            exitProcess(1)
        }
        exitProcess(0)
    }

    class SerdesDefinition(objectMapper: ObjectMapper) {
        val vehicle = JsonSerde(Vehicle::class.java, objectMapper)
        val price = JsonSerde(VehiclePrice::class.java, objectMapper)
        val photo = JsonSerde(VehiclePhoto::class.java, objectMapper)
        val photos = JsonSerde(VehiclePhotos::class.java, objectMapper)
        val partialVehicle = JsonSerde(PartialVehicle::class.java, objectMapper)
        val fullVehicle = JsonSerde(FullVehicle::class.java, objectMapper)
    }
}

fun main() {
    App().execute()
}
